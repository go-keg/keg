package annotations

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"

	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
	"github.com/samber/lo"
	"github.com/vektah/gqlparser/v2/ast"
)

const EnumName = "enums"

type Enums map[string]string

func (a Enums) Name() string {
	return EnumName
}

func (a Enums) Hooks() []gen.Hook {
	return []gen.Hook{
		func(next gen.Generator) gen.Generator {
			return gen.GenerateFunc(func(g *gen.Graph) error {
				for _, n := range g.Nodes {
					if err := generateEnums(n); err != nil {
						return err
					}
				}
				return next.Generate(g)
			})
		},
	}
}

func generateEnums(n *gen.Type) error {
	if len(n.EnumFields()) > 0 {
		dir := strings.ToLower(n.Name)
		_, file, _, _ := runtime.Caller(10)
		path := filepath.Join(filepath.Dir(file), dir, "enum_desc.go")
		content := renderEnums(n)
		return os.WriteFile(path, []byte(content), 0644)
	}
	return nil
}

func renderEnums(n *gen.Type) string {
	var b strings.Builder
	fmt.Fprintf(&b, "// Code generated by ent enumdesc. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "package %s\n\n", strings.ToLower(n.Name))
	for _, field := range n.EnumFields() {
		if v, ok := field.Annotations[EnumName]; ok {
			fmt.Fprintf(&b, "func (r %s) Description() string {\n", field.StructField())
			fmt.Fprintf(&b, "\treturn map[%s]string{\n", field.StructField())
			for _, enum := range field.Enums {
				fmt.Fprintf(&b, "\t\t%s: %s,\n", enum.Name, strconv.Quote(v.(map[string]any)[enum.Value].(string)))
			}
			fmt.Fprintf(&b, "\t}[r]\n}\n")
		}
	}
	return b.String()
}

func (a Enums) Annotations() []entc.Annotation {
	return nil
}

func (a Enums) Templates() []*gen.Template {
	return nil
}

func (a Enums) Options() []entc.Option {
	return nil
}

func EnumsGQLSchemaHook(graph *gen.Graph, schema *ast.Schema) error {
	for _, node := range graph.Nodes {
		for _, field := range node.Fields {
			for k, v := range field.Annotations {
				if k == EnumName {
					if enums, ok := v.(map[string]any); ok {
						if enum, ok := schema.Types[node.Name+lo.PascalCase(field.Name)]; ok {
							if enum.Kind == ast.Enum {
								for _, value := range enum.EnumValues {
									if item, ok := enums[value.Name]; ok {
										value.Description = item.(string)
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return nil
}
